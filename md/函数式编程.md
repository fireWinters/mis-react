一、函数是编程
1、定义
函数是编程是对计算过程的抽象（就是计算方法的封装），面向对象是对对象关系的封装（比如谁是谁的儿子）
2、例子
	（1）非函数式
    	let a = 1
        let b = 2
        let c = a + b
        上边这个就是计算过程，说明了c是a和b相加的产物
    （2）纯函数式
    	function count(a, b){
        	return c = a + b
        }
        
        let c = count(1, 2)
        上面是对计算过程的封装
        
二、函数是一等公民        
1、定义
	说白了就是函数什么都可以做
2、例子
	（1）存储到变量中
    	let fn = function asd(){
        	console.log('sdfsd')
            return 'sdsdf'
        }
        fu()
    （2）作为参数
    	//array：是要被处理的数组，fn是怎么处理的函数方法，fn是变换
    	function forEach(array, fn){
        	for(let i = 0; i < array.length; i++){
            	fn(array[i])//这里的fn是获取到集合中的每一项
            }
        }
        
        let asd = [1, 2, 3]
        forEach(asd, fn(item)){
        	console.log(item)
        }
    （3）作为返回值
    	function ssdf(){
        	let msg = 'Hello function'
        	return asd(){
            	console.log(msg)
            }
        }
        const fn = ssdf()//这种是吧一个函数赋值给另一个变量    
        fn()
        
        ssdf()()//这里的第一个括号是函数本身，第二个括号是函数里的返回函数
        
        //只调用一次的函数
        function once(fn){
        	let done = false//声明个变量判断用，如果变成true了就不会往下执行了
            return founction(){
            	if(!done){
                	done = true
                    return fn.apply(this, arguments)
                    //this是这个函数本身，arguments是这个函数的入参
                }
            }
        }
        
        let pay = once(function(money)){
        	console.log('支付：${money} RMB')
        })

三、高阶函数的意义
	1、那forEach循环举例，我们不用管循环过程，我们只看被循环的集合
    2、通用的部分可以整合到一个函数里
    3、例子
    	（1）模拟map
        	const map = (array, fn) => {//array是入参，fn是函数
            	let results = []
                for(let value of array){//循环入参
                	results.push(fn(value))//把循环的入参调用函数方法后，存到集合中
                }
                return results//最后返回集合
            }
            
            //测试
            let arr = [1, 2, 3, 4]
            arr = map(arr, v => v * v)
            console.log(arr)

四、闭包
	1、定义
    	函数因为引用了同一个作用域中的其他东西，捆绑在了一起，不能被立刻释放
    2、功能
    	可以在另一个作用域中调用一个函数的内部函数，并访问到该函数的作用域中的成员
    3、例子
    	//函数作为返回值
        function makeFn(){
        	let msg = 'hesdf'
            return function(){//如果没有这个函数内部打印msg,那么调用完makeFn后，msg就会被释放
            	console.log(msg)
            }
        }
    	
        const fn = makeFn()
        fn()
    4、闭包的本质
    	函数在执行的时候会放到一个执行栈上当函数执行完毕后会从执行栈上移除掉，但堆上的作用域成员		因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员
五、闭包案例
	//我们经常会计算求一个数的2次方，或者3次方，常用方法如下
    Math.pow(4, 2)//第一个参数是会变的，第二个一般不变
    Math.pow(5, 2)
    
    function makePower(power){//这个入参power是要确定做什么运算
    	return function(number){//这个number是确定谁被运算
        	return Math.pow(number，power)
        }
    }
    
    //求平方
    let power2 = makePower(2)//这里确定是求平方
    //求立方
    let power3 = makePower(3)
    
    console.log(power2(4))//这里的power2后边跟着的()，这个括号就是makePower里的方法
    
六、纯函数概念
	1、定义
    	入参不变返回值不变
    2、例子
    	//纯函数
        console.log(array.slice(0,3))
        console.log(array.slice(0,3))
        console.log(array.slice(0,3))
        //不纯的函数
        console.log(arraysplice(0,3))
        console.log(arraysplice(0,3))
        console.log(arraysplice(0,3))
        
        //纯函数  
        function getSum(n1, n2){
        	return n1 + n2
        }
        //这个函数不会保留计算中间结果，也就是n1 + n2,所以变量是不可变的（无状态的）

七、纯函数的好处
	1、可缓存
    	因为保持相同的结果，所以可以吧结果缓存起来
    2、列子
    	function getArea(r){
        	console.log(r)
            return Math.PI * r * r
        }
    
    	function memoize(f){//入参是个函数
        	let cache = {}
            return function(){
            	let key = JSON.stringify(arguments)//入参是数组，所以要先转换成json
                ceche[key] = cache[key] || f.apply(f, arguments)//这里判断下，如果当前的key有值直接赋值，没有的话就，把入参函数里的返回值进行赋值
                return cache[key]
            }
        }
        
        let getAreaWithMemory = memoize(getArea)
        console.log(getAreaWithMemory(4))
        console.log(getAreaWithMemory(4))
        console.log(getAreaWithMemory(4))
		//上述打印出的结果是否有改变
        
        3、总结
        	方便测试，可并行，因为只依赖入参，并不需要访问共享的内存数据
八、副作用
	如果函数是不纯的函数，那么他会依赖外部参数，外部参数的改变会影响函数的结果
        
九、柯里化
	1、如果一个函数有多个入参，我们可以 把他拆分成一个闭包的函数，最外层函数只接收一部分参数，并且这部分参数以后不会改变了，里面的函数接收其他参数，并返回结果。
    2、例子
    	//普通函数
        function checkAge(min, age){
        	return age >= min
        }
        //柯里化
        function checkAge(min){
        	return function(age){
            	return age >= min
            }
        }
        //es6
        let checkAge = min => (age => age >= min)
        
        let checkAge18 = checkAge(18)
        console.log(checkAge18(20))
       
十、Lodash中的柯里化方法
	1、功能
    	如果获取到全部入参，就会执行函数方法，如果只获取到部分入参，就会等待剩余入参
    2、示例
    	const _= requier('lodash')
        
        function getSum(a, b, c){
        	return a + b + c
        }
        
        const curried =_.curry(getSum)
        
        console.log(curried(1, 2, 3))
        console.log(curried(1)(2, 3))
        console.log(curried(1, 2)(3))

11、柯里化案例
	const match = _.curry(function(reg, str)){//第一个入参是正则表达式，第二个是要校验的字符串
    	return str.match(reg)//返回校验结果
    }
    
    const haveSpace = match(/\s+/g)//生成新的函数，后边调用的时候只传校验的字符串就行了
    const haveNumber = match(/\d+/g)
    
    const filter = _.curry(function(func, array)){//过了方法，第一个是是怎么过滤，第二个是被过滤得集合
    	return array.filter(func)
    }
    
    const findSpace = filter(haveSpace)//生成新的函数，按照校验是否有空格进行过滤
    
    console.log(filter(haveSpace, ['John Connor', 'John_Donne']))//这个是传俩个参数的
    console.log(findSpace(['John Connor', 'John_Donne']))//直接传被过滤对象就行

12、函数的组合概念
	（1）定义
    	如果有多个函数嵌套，会形成一个洋葱函数，就是一个函数返回结果后再给另一函数调用，出了问题都不知道是那的问题
    （2）例子
    	//组合函数演示
    	function compose(f, g){//先执行右边的
        	return function(value){//接收入参
            	return f(g(value))//先调用g, 再把结果给f调用
            }
        }
        
        //俩个前置函数
       	function reverse(array){
        	return array.reverse()
        }
        
        function first(array){
        	return array[0]
        }
    
    	const last = compose(first, reverse)//先反转，再取第一个数
        
        console.log(last([1, 2, 3, 4]))
        
 13、lodash中的函数组合的方法
    （1）例子
    	const reverse = arr => arr.reverse()
        const first = arr => arr[0]
        const toUpper = s => s.toUpperCase()
        
        const f = _.flowRight(toUpper, first, reverse)
        console.log(f['one', 'two', 'three'])

     （2）模仿
         function compose(...args){//args代表多个入参
             return function(value){
                //args.revers()是反转数组，为例模拟上边的从右往左执行方法
                //reduce()方法是对数组中的每一项都执行一个函数，并把他们的结果整合在一起返回
                return args.revers().reduce(function(acc,fn){//acc是处理结果，fn是怎么处理结果，这里的fn就是上边的各个函数
                    return fn(acc)
                },value)//这里的value是给acc的初始值
             }
         }
     （3）简化
          const compose = (...args) => value => args.reverse().reduce((acc,fn) => fn(acc),value) 
14、函数数组的结合律（associativity）
    //我们既可以把g和h组合，还可以把f和g组合，结果都是一样的
15、
16、lodash-fp模块
    （1）功能：提供了使用的对函数式编程友好的方法，提供了不可变“auto-curried iteratee-first data-last”的方法
    （2）例子
        //lodash模块
        const _= require('lodash')
        _.map(['a', 'b', 'c'], _.toUpper)//这里lodash的map方法是先获取参数，后调用方法
        //lodash/fp模块
        const fp = require('lodash/fp')
        fp.map(fp.toUpper,['a', 'b', 'c'])//可以先执行方法后执行参数

17、lodash和lodash/fp模块中map的方法的区别
    （1）lodash的map方法是先调用参数，再调用函数
        console.log(_.map(['23', '8', '10'], parseInt))
        //这里的parseInt是使用三个参数的，第一个参数是要处理的值，第二个是变成几进制的，第三个是整个集合，所以会产生问题
    （2）fp的方法
        console.log(fp.map(parseInt, ['23', '8', '10']))    
        //这里的parseInt只有一个入参，就是当前元素
        
18、point free
    （1）定义：把数据和处理数据的过程分开，不用代表数据的那个参数，只把简单的运算步骤合成到一起，在使用这个合成的运算步骤之前，我们要定义一些基础的运算方法    
        1）不需要指明处理的数据
        2）只需要合成运算过程
        3）需要定义一些辅助的基本运算函数
    （2）举例：
        //把Hello World 变成 hello_world
        //非point free模式
        function f(word){
            return word.toLowerCase().replace(/\s+/g, '_');//这里直接
        }
        
        //point free
        const fp = require('lodash/fp')
        const f = fp.flowRight(fp.replace(/\s+/g, '_'), fptoLower)//这里是调用俩个小的基础的方法
        
19、functor
    （1）定义
        定一个一个容器，如下边示例，class就是容器，在容器里边定义一个初始值和对这个值进行操作的变化函数
    （2）例子
        class Container(){
            static of (value){//声明成静态变量了，以后就不用new这个对象了
                return new Container(value)
            }
            constructor(value){
                this._value = value//这里的下划线_.value是为了把入参私有化
            }
            map (fn){
                return Container.of(fn(this._value))//这里的map返回Container对象
            } 
        }
        let r = Container.of(5)//入参是5
            .map(x => x + 2)//这会进行的处理是5+2，x等于7
            .map(x => x * x)//下边这里的x是7*7，r等于49
        console.log(r)
20、functor总结
    （1）函数式变成的运算不直接操作值，是由函子完成
    （2）函子就是一个实现了map契约的对象
    （3）我们可以把函子想象成一个盒子，这个盒子里封装了一个值
    （4）想要处理盒子中的值，我们需要给盒子的map方法传递一个处理值的函数（纯函数），由这个函数对值进行处理
    （5）最终map方法返回一个包含新值的盒子（函子）
    （6）副作用：当纯函数遇到入参为null的时候就会报错
        //演示null undefined的问题
        Container.of(null)
            .map(x => x.toUpperCase())
21、MayBe函子
    （1）定义：
        我们在编程过程中遇到错误需要进行处理，就相当于try...catch
    （2）功能：
        MayBe函子的作用就是可以对外部的空值进行处理（控制副作用的范围）
    （3）例子
        class MayBe{
            static of (value){
                return new MayBe(value)
            }
            constructor (){
                this._value = value
            }
            //如果对空值变形的话直接返回 值为null的函子
            map (fn){
                return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this._value))
            }
            isNothing (){
                return this._value === null || this._value === undefined
            }
        }

        //传入具体值
        let r = MayBe.of('Hello World')
                    .map(x => x.toUpperCase())

        //传入null
        let r = MayBe.of(null)
                    .map(x => x.toUpperCase())
        console.log(r)

22、Either函子
    （1）定义
        either俩者中的任何一个，类似于if...else...的处理
    （2）功能
        异常会让函数变的不纯，either函子可以用来做异常处理
    （3）例子
        //用来抛异常的方法
        class left｛
            static of (value){
                return new left(value)
            }
            constructor (value){
                this._value = value
            }
            map (fn){
                return this//这个不调用函数，只返回自己本身，后续用来接收异常
            }
        ｝
        //执行正确的方法
        class right(){
            static of (value){
                return new Right(value)
            }
            constructor (value){
                this._value = value
            }
            map(fn){
                return right.of(fn(this._value))
            }
        }
        //异常处理
        function parseJSON (str){
            try {
                return right.of(JSON.parse(str))
            } catch (e) {
                return left.of({ errir : e.message})
            }
        }
        //正确的入参调用
        let r = parseJSON('{"name" : "zs"}')
        console.log(r)
        //有异常的调用
        let r = parseJSON('{name : zs}')
        console.log(r)

23、IO函子
    （1）定义
        1）IO函子中的_value是一个函数，这里是把函数作为值来处理
        2）IO函子可以把不纯的动作存储到_value中，延迟执行这个不纯的操作（惰性执行），包装当前的操作纯函数
        3）把不纯的操作交给调用者处理
    （2）举例
        const fp = require('lodah/fp')
        class IO{
            static of(x){
                return new IO(function(){//包装成函数
                    return x
                })
            }
            constructor (fn) {
                this._value = fn//把函数当作value处理
            }
            map (fn){
                //把当前的value和值传入的fn组合成一个新的函数
                return new IO(fp.flowRight(fn, this._value))
            }
        }
        
        //调用
        let r = IO.of(process).map(p => p.execPath)//这里的process是函数，然后调用map把p这个函数和process结合成一个函数
        console.log(r)

24、Task异步执行
	（1）异步任务的实现过于复杂，我们使用folktale中的Task来演示
	（2）folkta一个标准的函数式编程库
		1）和lodash、ramda不同的是，他没有提供很多功能函数
		2）只提供了一些函数式处理的操作，例如：compose、curry等，一些函子Task、Either、MayBe等
		
	（3）例子
		const {compose, curry} = require('folktale/core/lambda')
		const {toUpper, first} = require('lodash/fp')
		
		//第一个参数是传入函数的参数个数
		let f = curry(2, function(x, y){
			console.log(x + y)
		})
		f(3, 4)
		f(3)(4)
		
		//函数组合
		let f = compose(toUpper, first)
		f(['one', 'two'])
		
	（4）版本
		1）folktale(2.3.2)2.x中的Task和1.0中的Task区别很大，1.0中的用法更接近我们现在演示的函子
		2）这里以2.3.2来演示
		
25、Pointed函子
	（1）Pointed函子是实现了of静态方法的函子
	（2）of方法是为了避免使用new来创建对象，更深层的含义是of方法用来把值放到上下文Context（把值放到容器中，使用map来处理值）
	（3）例子
		class Container{
			static of(value){//of方法帮我们把值包过到一个新的函子里，并返回这个函子
				return new Container(value)
			}
			...
		}
		
		Contanier.of(2)
			.map(x => x + 5)
			
26、IO函子问题
	（1）例子
		let readFile = function (filename){
			return new IO(function(){
				return fs.readFileSync(filename, 'utf-8')
			})
		}
		
		let print = function (x){
			return new IO(function(){
				console.log(x)
				return x
			})
		}
		
		let cat = fp.flowRight(print, readFile)//这里先执行获取文件的方法，再执行打印的方法
		//IO(IO(x))，这里其实是第一个方法返回了一个IO函子，作为入参给了打印方法
		let r = cat('package.json')._value()._value()//所以打印第一._value()获取的readFile这个函子，第二才是文件
		console.log(r)
		
27、Monad函子
	（1）定义
		Monad函子是可以变扁的Pointed函子，IO(IO(x))
	（2）功能
		一个函子如果具有join和of俩个方法并遵守一些定律就是一个Monad
	（3）举例
		const fp = require('lodah/fp')
		class IO{
		    static of(x){
		        return new IO(function(){//包装成函数
		            return x
		        })
		    }
		    constructor (fn) {
		        this._value = fn//把函数当作value处理
		    }
		    map (fn){
		        //把当前的value和值传入的fn组合成一个新的函数
		        return new IO(fp.flowRight(fn, this._value))
		    }
			join (){//这个方法返回当前函子的value
				return this._value()
			}
			flatMap (fn){//这个是结合了map和join俩个方法,如果是嵌套IO函子用这个方法
				return this.map(fn).join()
			}
		}
		
		let readFile = function (filename){
			return new IO(function(){
				return fs.readFileSync(filename, 'utf-8')
			})
		}
		
		let print = function (x){
			return new IO(function(){
				console.log(x)
				return x
			})
		}
		
		let r = readFile('package.json')
				.map(fp.toUpper)//这里可以对函子里的值进行操作
				.flatMap(print)//这时候获取的是函子
				.join()//这是候获取的就是函子里的值了
				
		console.log(r)
				